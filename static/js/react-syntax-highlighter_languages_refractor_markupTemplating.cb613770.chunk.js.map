{"version":3,"sources":["../node_modules/refractor/lang/markup-templating.js"],"names":["markupTemplating","Prism","languages","Object","defineProperties","buildPlaceholders","value","env","language","placeholderPattern","replaceFilter","tokenStack","code","replace","match","i","length","indexOf","toUpperCase","grammar","markup","tokenizePlaceholders","j","keys","walkTokens","tokens","token","content","k","t","s","index","replacement","before","substring","middle","Token","tokenize","after","filter","v","Array","prototype","splice","apply","concat","module","exports","displayName","aliases"],"mappings":"2FAMA,SAAAA,EAAAC,GACAA,EAAAC,UAAA,wBACAC,OAAAC,iBAAAH,EAAAC,UAAA,sBACAG,kBAAA,CAIAC,MAAA,SAAAC,EAAAC,EAAAC,EAAAC,GACAH,EAAAC,eAIAD,EAAAI,WAAA,GACAJ,EAAAK,KAAAL,EAAAK,KAAAC,QAAAJ,EAAA,SAAAK,GACA,uBAAAJ,MAAAI,GACA,OAAAA,EAKA,IAFA,IAAAC,EAAAR,EAAAI,WAAAK,QAEA,IAAAT,EAAAK,KAAAK,QAAA,MAAAT,EAAAU,cAAAH,EAAA,UACAA,EAKA,OADAR,EAAAI,WAAAI,GAAAD,EACA,MAAAN,EAAAU,cAAAH,EAAA,QAGAR,EAAAY,QAAAlB,EAAAC,UAAAkB,UAGAC,qBAAA,CAEAf,MAAA,SAAAC,EAAAC,GACA,GAAAD,EAAAC,cAAAD,EAAAI,WAAA,CAKAJ,EAAAY,QAAAlB,EAAAC,UAAAM,GACA,IAAAc,EAAA,EACAC,EAAApB,OAAAoB,KAAAhB,EAAAI,aAEA,SAAAa,EAAAC,GACA,KAAAH,GAAAC,EAAAP,QAIA,QAAAD,EAAA,EAAyBA,EAAAU,EAAAT,OAAmBD,IAAA,CAC5C,IAAAW,EAAAD,EAAAV,GAEA,qBAAAW,KAAAC,SAAA,kBAAAD,EAAAC,QAAA,CACA,IAAAC,EAAAL,EAAAD,GACAO,EAAAtB,EAAAI,WAAAiB,GACAE,EAAA,kBAAAJ,MAAAC,QACAI,EAAAD,EAAAb,QAAA,MAAAT,EAAAU,cAAAU,EAAA,OAEA,GAAAG,GAAA,KACAT,EACA,IAGAU,EAHAC,EAAAH,EAAAI,UAAA,EAAAH,GACAI,EAAA,IAAAlC,EAAAmC,MAAA5B,EAAAP,EAAAoC,SAAAR,EAAAtB,EAAAY,QAAAX,GAAA,YAAAA,EAAAqB,GACAS,EAAAR,EAAAI,UAAAH,GAAA,MAAAvB,EAAAU,cAAAU,EAAA,OAAAZ,QAkBA,GAfAiB,GAAAK,EAIAd,EAHAQ,EAAA,CAAAC,EAAAE,EAAAG,GAAAC,OAAA,SAAAC,GACA,QAAAA,KAIAR,EAAAG,EAGA,kBAAAT,EACAe,MAAAC,UAAAC,OAAAC,MAAAnB,EAAA,CAAAV,EAAA,GAAA8B,OAAAb,IAEAN,EAAAC,QAAAK,EAGAV,GAAAC,EAAAP,OACA,YAGaU,EAAAC,SAAA,kBAAAD,EAAAC,SACbH,EAAAE,EAAAC,UAKAH,CAAAjB,EAAAkB,aA9FAqB,EAAAC,QAAA/C,EACAA,EAAAgD,YAAA,mBACAhD,EAAAiD,QAAA","file":"static/js/react-syntax-highlighter_languages_refractor_markupTemplating.cb613770.chunk.js","sourcesContent":["'use strict';\n\nmodule.exports = markupTemplating;\nmarkupTemplating.displayName = 'markupTemplating';\nmarkupTemplating.aliases = [];\n\nfunction markupTemplating(Prism) {\n  Prism.languages['markup-templating'] = {};\n  Object.defineProperties(Prism.languages['markup-templating'], {\n    buildPlaceholders: {\n      // Tokenize all inline templating expressions matching placeholderPattern\n      // If the replaceFilter function is provided, it will be called with every match.\n      // If it returns false, the match will not be replaced.\n      value: function value(env, language, placeholderPattern, replaceFilter) {\n        if (env.language !== language) {\n          return;\n        }\n\n        env.tokenStack = [];\n        env.code = env.code.replace(placeholderPattern, function (match) {\n          if (typeof replaceFilter === 'function' && !replaceFilter(match)) {\n            return match;\n          }\n\n          var i = env.tokenStack.length; // Check for existing strings\n\n          while (env.code.indexOf('___' + language.toUpperCase() + i + '___') !== -1) {\n            ++i;\n          } // Create a sparse array\n\n\n          env.tokenStack[i] = match;\n          return '___' + language.toUpperCase() + i + '___';\n        }); // Switch the grammar to markup\n\n        env.grammar = Prism.languages.markup;\n      }\n    },\n    tokenizePlaceholders: {\n      // Replace placeholders with proper tokens after tokenizing\n      value: function value(env, language) {\n        if (env.language !== language || !env.tokenStack) {\n          return;\n        } // Switch the grammar back\n\n\n        env.grammar = Prism.languages[language];\n        var j = 0;\n        var keys = Object.keys(env.tokenStack);\n\n        var walkTokens = function walkTokens(tokens) {\n          if (j >= keys.length) {\n            return;\n          }\n\n          for (var i = 0; i < tokens.length; i++) {\n            var token = tokens[i];\n\n            if (typeof token === 'string' || token.content && typeof token.content === 'string') {\n              var k = keys[j];\n              var t = env.tokenStack[k];\n              var s = typeof token === 'string' ? token : token.content;\n              var index = s.indexOf('___' + language.toUpperCase() + k + '___');\n\n              if (index > -1) {\n                ++j;\n                var before = s.substring(0, index);\n                var middle = new Prism.Token(language, Prism.tokenize(t, env.grammar, language), 'language-' + language, t);\n                var after = s.substring(index + ('___' + language.toUpperCase() + k + '___').length);\n                var replacement;\n\n                if (before || after) {\n                  replacement = [before, middle, after].filter(function (v) {\n                    return !!v;\n                  });\n                  walkTokens(replacement);\n                } else {\n                  replacement = middle;\n                }\n\n                if (typeof token === 'string') {\n                  Array.prototype.splice.apply(tokens, [i, 1].concat(replacement));\n                } else {\n                  token.content = replacement;\n                }\n\n                if (j >= keys.length) {\n                  break;\n                }\n              }\n            } else if (token.content && typeof token.content !== 'string') {\n              walkTokens(token.content);\n            }\n          }\n        };\n\n        walkTokens(env.tokens);\n      }\n    }\n  });\n}"],"sourceRoot":""}